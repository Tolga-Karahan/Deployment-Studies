#  There are 3 types of volumes in k8s: EmptyDir, hostPath, PersistentVolume.

# EmptyDir is a volume in the Pod level. Thus it depends on the lifecycle of the
# Pod. When the pod restarts the data still persists, but when the pod replaced by
# another one then data is gone.
spec:
  containers:
    - name: EmptyDirContainer
      image: aImage
      volumeMounts: 
      - name: data
        mountPath: /data
  
  volumes:
    - name: data
      emptyDir: {}

# HostPath is a volume in Node level. It resilient to Pod replacements, so new Pod
# can also use the data that generated by previous one, but if new replacement is
# run on different Node then previous data can't be reachable. We can force k8s to run
# replacement pods in the same node, but of course it decreases the resilience of the 
# deployment. Another problem is security related. Because k8s doesn't restrict HostPath
# to access to file system of the node. 
---
spec:
  containers:
    - name: HostPathContainer
      image: aImage
      volumeMounts:
      - name: data
        mounthPath: /data
  
  volumes:
    - name: data
      hostPath:
        path: /volumes/data
        type: DirectoryOrCreate

# By declaring subpaths for the volume mount we can restrict access to a specific path.
---
spec:
  containers:
  - name: MoreSecureHostPathContainer
    image: aImage
    volumeMounts:
    - name: node-root
      mounthPath: /pod-logs
      subPath: var/log/pods

    - name: node-root
      mountPath: /container-logs
      subPath: var/log/containers
  
  volumes:
    - name: node-root
      hostPath: 
        path: /
        type: Directory

# In order to make pods to access volumes from any nodes, a distributed architecture must be used.
# Volume type depends on the underlying distributed file system. For example Azure files in AKS,
# Elastic Block Store in EKS etc... These all have different configuration requirements that can be
# specified in the volume spec for pods, but it makes application to tightly coupled to a specific
# storage implementation. 

# A piece of storage is defined by a PersistentStorage object that contains volume specs for underlying
# storage system and claimed by PersistenStorageClaims which is a storage abstraction that pods uses. 
# PVC just states its storage requirements, it doesn't state anything regarding volume implementation.
# PVC gets matched to a PV by Kubernetes and it leaves the underlying volume details to the PV. 
# PersistentStorage is available if it's not claimed by any PersistentVolumeClaim.
---
apiVersion: v1
kind: PersistentVolume
metadata:
  name: mypv
spec:
  capacity:
    storage: 50 Mi
  accessModes:
    - ReadWriteOnce
  local:
    path: /volumes/pv01
  nodeAffinity:
    required:
      nodeSelectorTerms:
        - matchExpressions:
          - key: my_key
            operator: In
            values:
              - base

# If we leave storage class empty, then k8s tries to find an existing PV that matches with the 
# requirements that specified in the PVC. If it is successful then PVC is bound. If PVC is not
# bound, a pod can't utilize it. Pod still can be created, but stays in pending state until
# PVC is bound. 

# PersistentVolumes are dependent on the underlying infrastructure, so admins of k8s cluster must
# create these PersistenVolumes and application designer only uses PersistenVolumeClaims.
---
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: sample-pvc
spec:
  resources:
    requests:
      storage: 40Mi
  accessModes:
    - ReadWriteOnce
  storageClassName: ""

# Instead of statically defining PVs and bounding PVCs to them, we can use dynamic provisioning.
# In that setup, only PVC is created and corresponding PV is created on dynamically by the cluster
# with the specified storage classes. Clusters can be configured to provide different storage classes
# as well as a default one. Then PVCs can choose any of them or by omitting storage class field they 
# can use the default one. 

# Storage classes can be created as k8s resources and in the spec part how the storage class works
# is defined with three fields: provisioner, reclaimPolicy, volumeBindingMode. In provisioner field,
# component that creates PVs on demand is defined. reclaimPolicy is about what to do when PVC is gone.
# volumeBindingMode is about the time that PV is created, whether as soon as there is a claim or when
# a pod starts to use the claim. 